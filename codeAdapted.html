<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
  </head>
  <body>
    
    
function off(){
  

// Gmail2GDrive
// https://github.com/ahochsteger/gmail2gdrive

// GMail Label setup.
// Returns the label with the given name or creates it if not existing.
function getOrCreateLabel(labelName) {
  var label = GmailApp.getUserLabelByName(labelName);
  if (label == null) {
    label = GmailApp.createLabel(labelName);
  }
  return label;
}

// GDrive Folder Setup.
// Recursive function.
// Create and return a complete folder path.
function getOrCreateSubFolder(baseFolder,folderArray) {
  
  if (folderArray.length == 0) { return baseFolder; }
  
  var nextFolderName = folderArray.shift();
  var nextFolder = null;
  var folders = baseFolder.getFolders();
  
  while (folders.hasNext()) {
    var folder = folders.next();
    if (folder.getName() == nextFolderName) {
      nextFolder = folder;
      break;
    }
  }
  
  if (nextFolder == null) { nextFolder = baseFolder.createFolder(nextFolderName); }
  
  return getOrCreateSubFolder(nextFolder,folderArray);
}


// GDrive Folder find, by path.
// Returns the GDrive folder from the given path.
function getFolderByPath(path) {
  var parts = path.split("/");

  if (parts[0] == '') parts.shift(); // Did path start at root, '/'?

  var folder = DriveApp.getRootFolder();
  
  for (var i = 0; i < parts.length; i++) {
    var result = folder.getFoldersByName(parts[i]);
    if (result.hasNext()) {
      folder = result.next();
    } else {
      throw new Error( "folder not found." );
    }
  }
  return folder;
}


// GDrive Folder find, by name.
// Returns the GDrive folder from the given name.
function getOrCreateFolder(folderName) {
  var folder;
  
  try {
    folder = getFolderByPath(folderName);
  } catch(e) {
    var folderArray = folderName.split("/");
    folder = getOrCreateSubFolder(DriveApp.getRootFolder(), folderArray);
  }
  return folder;
}


// Returns a new filename using 'rule.filenameTo' from config.gs
function NewFileName(id, name, date, filenameTo, timezone,type) {
    
  Logger.log("INFO-NEW: Create a new  filename.");   
 // filename = Utilities.formatDate(date, config.timezone, rule.filenameTo.replace('%s',name));
  
  filename = Utilities.formatDate(date, timezone, filenameTo)
  filename = filename.replace('%s',name);
  id = id.substr(id.length-3, 3);
  filename = filename.replace('%id',id);
  filename = filename.replace('%t',type);
  filename = filename.replace('[toread] ','');
  filename = filename.substr(1, 150);

  Logger.log("INFO-NEW: Created a new  filename: " + filename);
  return filename;
}


// Process a message: extract attachement one by one,  upload it, rename it and add a description
function processMessage(message, rule, config) {
  Logger.log("INFO:       Processing message: "+message.getSubject() + " (" + message.getId() + ")");
  
  var messageDate = message.getDate();
  var attachments = message.getAttachments();
  
  for (var attIdx=0; attIdx<attachments.length; attIdx++) {
    var attachment = attachments[attIdx];
    
    Logger.log("INFO:         Processing attachment: "+attachment.getName());
    
    var match = true;
    
    if (rule.filenameFromRegexp) {
      var re = new RegExp(rule.filenameFromRegexp);
      match = (attachment.getName()).match(re);
    }
    
    if (!match) {
      Logger.log("INFO:           Rejecting file '" + attachment.getName() + " not matching" + rule.filenameFromRegexp);
      continue;
    }
    
    try {
       Logger.log("INFO:  var folder");
       var folder = getOrCreateFolder(rule.folder);

       Logger.log("INFO:  var file");
       var file = folder.createFile(attachment);
       
       Logger.log("INFO:  var filename");
       var filename = file.getName();
       Logger.log("INFO:  " + filename);
   
      filename = NewFileName(message.getId(),filename, messageDate, rule.filenameTo, config.timezone,"file");
      
      file.setName(filename);
      file.setDescription("Mail title: " + message.getSubject() + "\nMail date: " + message.getDate() + "\nMail link: https://mail.google.com/mail/u/0/#inbox/" + message.getId() + "\nMail body:" + message.getPlainBody());

      Utilities.sleep(config.sleepTime);
    } catch (e) {
      Logger.log(e);
    }
  }
}

/**
 * Generate HTML code for one message of a thread.
 */
function processThreadToHtml(thread) {
  Logger.log("INFO:   Generating HTML code of thread '" + thread.getFirstMessageSubject() + "'");
  var messages = thread.getMessages();
  var html = "";
  for (var msgIdx=0; msgIdx<messages.length; msgIdx++) {
    var message = messages[msgIdx];
    html += "From: " + message.getFrom() + "<br />\n";
    html += "To: " + message.getTo() + "<br />\n";
    html += "Date: " + message.getDate() + "<br />\n";
    html += "Subject: " + message.getSubject() + "<br />\n";
    html += "<hr />\n";
    html += message.getBody() + "\n";
    html += "<hr />\n";
  }
  return html;
}

/**
* Generate a PDF document for the whole thread using HTML form .
 */
function processThreadToPdf(thread, rule,config) {
  Logger.log("INFO: Saving PDF copy of thread '" + thread.getFirstMessageSubject() + "'");
  var folder = getOrCreateFolder(rule.folder);
  var html = processThreadToHtml(thread);
  var blob = Utilities.newBlob(html, 'text/html');
  var messages = thread.getMessages();
  var message = messages[0];
  
  filename = NewFileName(message.getId(),message.getSubject(), message.getDate(), rule.filenameTo, config.timezone,"mail") + ".pdf";
  
    Logger.log("INFO:   Toujours la.");

//  var pdf = folder.createFile(blob.getAs('application/pdf')).setName(filename);
//  return pdf;

  folder.createFile(blob.getAs('application/pdf')).setName(filename);
  return 1;
}

/**
 * Main function that processes Gmail attachments and stores them in Google Drive.
 * Use this as trigger function for periodic execution.
 */
function Gmail2GDrive() {
  if (!GmailApp) return; // Skip script execution if GMail is currently not available (yes this happens from time to time and triggers spam emails!)
 
  var config = getGmail2GDriveConfig();
  var label = getOrCreateLabel(config.processedLabel);
  var end, start, runTime;
 
  start = new Date(); // Start timer

  Logger.log("INFO: Starting mail attachment processing.");
  
  if (config.globalFilter===undefined) {
    config.globalFilter = "has:attachment -in:trash -in:drafts -in:spam";
  }

  // Iterate over all rules:
  for (var ruleIdx=0; ruleIdx<config.rules.length; ruleIdx++) {
    
    var rule = config.rules[ruleIdx];
    var gSearchExp  = config.globalFilter + " " + rule.filter + " -label:" + config.processedLabel;
    
    var folder = getOrCreateFolder(rule.folder);

    //Create the log Google Spreadsheet file.
    var rootFolder = DriveApp.getRootFolder();
    var logfname   = "log" + Utilities.formatDate(new Date(), "GMT", "yyyyMMdd'T'HH:mm:ss'Z'");
    var folderId   = rootFolder.getFoldersByName(rule.folder).next().getId();
    
    var resource = {
      title: logfname,
      mimeType: MimeType.GOOGLE_SHEETS,
      parents: [{ id: folderId }]
    }
  
    var fileJson = Drive.Files.insert(resource)
    //Log Google Spreadsheet file created.

    var fileId = fileJson.id
    Logger.log("INFO:   FileId: "+fileId);

    // This code uses the Sheets Advanced Service, but for most use cases
    // the built-in method SpreadsheetApp.getActiveSpreadsheet()
    //     .getRange(range).setValues(values) is more appropriate.
    var values = [
    
      [
        "Mail title"
      ],
      [
        "Mail date"
      ],
      [
        "Mail id"
      ],
      [
        "Mail link"
      ],
      [
        "Mail body"
      ]
      
    ];
    
    var valueRange = Sheets.newValueRange();
    valueRange.values = values;
    
    Sheets.Spreadsheets.Values.update(resource, spreadsheetId, range, optionalArgs)
    var result = Sheets.Spreadsheets.Values.update(valueRange, fileId, "A1", {
       "majorDimension": "COLUMNS"
    }
    );

  //    file.setDescription("Mail title: " + message.getSubject() + "\nMail date: " + message.getDate() + "\nMail link: https://mail.google.com/mail/u/0/#inbox/" + message.getId() + "\nMail body:" + message.getPlainBody());
  
exit;

 //   folder.addFile(Excelfile);
 //   var Excelfile = folder.addFile( DocumentApp.create("log.spreadsheet") );

// Exception: Les paramètres (DocumentApp.Document) ne correspondent pas à la signature de la méthode "DriveApp.Folder.addFile". (ligne 218, fichier "Code")

    if (config.newerThan != "") {
      gSearchExp += " newer_than:" + config.newerThan;
    }
    
    var doArchive = rule.archive == true;
    var doPDF = rule.saveThreadPDF == true;

    // Process all threads matching the search expression:
    var threads = GmailApp.search(gSearchExp);
    Logger.log("INFO:   Processing rule: "+gSearchExp);
    
    for (var threadIdx=0; threadIdx<threads.length; threadIdx++) {
      var thread = threads[threadIdx];

      end = new Date();
      runTime = (end.getTime() - start.getTime())/1000;
      Logger.log("INFO:     Processing thread: "+thread.getFirstMessageSubject() + " (runtime: " + runTime + "s/" + config.maxRuntime + "s)");
      
      if (runTime >= config.maxRuntime) {
        Logger.log("WARNING: Self terminating script after " + runTime + "s");
        return;
      }

      // Process all messages of a thread:
      var messages = thread.getMessages();
      
      for (var msgIdx=0; msgIdx<messages.length; msgIdx++) {
        var message = messages[msgIdx];
        processMessage(message, rule, config);
      }
      
      if (doPDF) { // Generate a PDF document of a thread:
        processThreadToPdf(thread, rule,config);
      }

      // Mark a thread as processed:
      thread.addLabel(label);

      if (doArchive) { // Archive a thread if required
        Logger.log("INFO:     Archiving thread '" + thread.getFirstMessageSubject() + "' ...");
        thread.moveToArchive();
      }
    }
  }
  
  end = new Date(); // Stop timer
  runTime = (end.getTime() - start.getTime())/1000;
  Logger.log("INFO: Finished mail attachment processing after " + runTime + "s");
}

}


    
    
  </body>
</html>


